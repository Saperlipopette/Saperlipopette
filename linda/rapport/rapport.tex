\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx} % pour les images
\usepackage{amsmath} % les trois packages suivants sont pr les maths
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{listings} % pour l'affichage du code
\usepackage{color}

\lstset{ %
	language=Java,        % choix du langage
	basicstyle=\footnotesize,       % taille de la police du code
	numbers=left,                   % placer le numéro de chaque ligne à gauche (left) 
	numberstyle=\normalsize,        % taille de la police des numéros
	numbersep=7pt,            % distance entre le code et sa numérotation
	backgroundcolor=\color{white},
	commentstyle=\color{blue}
}
\makeatletter
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
\hbox to \hsize{%
\vbox{\centering #1}}}%
\def\haut#1#2#3{%
\hbox to \hsize{%
\rlap{\vtop{\raggedright #1}}%
\hss
\clap{\vtop{\centering #2}}%
\hss
\llap{\vtop{\raggedleft #3}}}}%
\def\bas#1#2#3{%
\hbox to \hsize{%
\rlap{\vbox{\raggedright #1}}%
\hss
\clap{\vbox{\centering #2}}%
\hss
\llap{\vbox{\raggedleft #3}}}}%
\def\maketitle{%
\thispagestyle{empty}\vbox to \vsize{%
\haut{}{\@blurb}{}
\vfill
\vspace{1cm}
\begin{flushleft}
\usefont{OT1}{ptm}{m}{n}
\huge \@title
\end{flushleft}
\par
\hrule height 4pt
\par
\begin{flushright}
\usefont{OT1}{phv}{m}{n}
\Large \@author
\par
\end{flushright}
\vspace{1cm}
\vfill
\vfill
\bas{}{\@location, le \@date}{}
}%
\cleardoublepage
}
\def\date#1{\def\@date{#1}}
\def\author#1{\def\@author{#1}}
\def\title#1{\def\@title{#1}}
\def\location#1{\def\@location{#1}}
\def\blurb#1{\def\@blurb{#1}}
\date{13 Janvier 2015}
\author{}
\title{}
\location{Toulouse}\blurb{}
\makeatother
\title{Rapport du projet de systèmes concurrents / intergiciels }
\author{Olivier Lienhard \\ Tom Lucas \\ Thibault Hilaire}
\location{Toulouse}
\blurb{%\blurb
École nationale supérieure d'électrotechnique, d'électronique, d'informatique, d'hydraulique et des télécommunications\\
\textbf{Filière Informatique et Mathématiques appliquées}\\[1em]
}% 



\begin{document}

\maketitle

\renewcommand{\contentsname}{Sommaire}
\renewcommand{\chaptername}{Partie}
\tableofcontents % pour que latex génére le sommaire

\chapter{Choix de la spécification libérale}

Explications des différents choix de la spécification libérale :
\begin{itemize}
 \item quand plusieurs tuples correspondent, take retourne le premier à avoir été écrit dans la mémoire (FIFO)
 \item quand plusieurs take sont en attente et qu'un dépôt peut en débloquer plusieurs, on débloque le premier take à avoir demandé (FIFO)
 \item quand des read et un take sont en attente, et qu'un dépôt peut les débloquer, on les débloque dans l'ordre de demande (FIFO)
 \item quand il y a un take et un callback enregistré pour le même motif, le take est prioritaire
\end{itemize}

\chapter{Version en mémoire partagée}

\section{Choix d'implémentation}

Voici les différentes structures choisies pour respecter nos choix de spécification:
\begin{itemize}
 \item Collection<Tuple> tuples : pour sauvegarder nos tuples qui ont été écrits dans la mémoire, et les enlever lors d'un take
 \item	Map<Tuple, LinkedList<Integer>> MatchEnAttente : cette map va permettre de stocker tous les take/read bloquants 
 \item int id : un entier qui nous permettra de simuler notre FIFO, de savoir dans quels ordres les take/read ont été écrits dans notre map
 \item ArrayList<Condition> classe : un ensemble de conditions liées à un Lock, dont on associera chaque condition à un take/read bloquants
 \item Condition writeCondition : une condition qui va nous permettre de faire une priorité au signalé lors du réveil d'un take/read
 \item Boolean takeEffectue : un booléen permettant de vérifier, lors d'un write, si un take a été effectué
\end{itemize}


A partir de ceci, on peut expliquer l'algorithme de la fonction write :

Tout d'abord on ajoute le tuple dans la collection de tuples. Ensuite on récupère les templates dont le tuple ajouté correspond (i.e. tuple.matches(template)==true), ce qu'on appelle
les templatesCorrespondants. Puis tant que cette collection de templatesCorrespondants n'est pas vide ET qu'un take (sur ce tuple ajouté) n'a pas
été effectué (vérifiable sur notre booléen takeEffectue), on réveille le premier template correspondant (celui dont l'indice id est le plus bas).
Si un take est effectué, le booléen takeEffectue devient vrai, on sort de la boucle et on ne réveille pas les callback et la fonction write est finie.
Sinon, si aucun take n'est effectué et si on a parcouru toute la liste des templatesCorrespondants, on notifie les callback qui sont des observateurs.
Un tel algorithme garantit alors le respect de la spécification ci-dessus, qui est ensuite validée par les tests décrits ci-dessous.

\section{Tests}

Pour les tests, outre les tests donnés, des tests unitaires sont effectués pour chaque fonction pour chaque type de paramètre différent (notamment pour les callback). Ainsi une liste non exhaustive des tests unitaires principaux est :
\begin{itemize}
\item BasicTestAsyncCallbackReadFuture.java
\item BasicTestAsyncCallbackReadImmediate.java
\item BasicTestAsyncCallbackTakeFuture.java
\item BasicTestAsyncCallbackTakeImmediate.java
\item BasicTestCallbackReadFuture.java
\item BasicTestCallbackReadImmediate.java
\item BasicTestCallbackTakeFuture.java
\item BasicTestCallbackTakeImmediate.java
\item BasicTestRead.java
\end{itemize}
D'autres tests unitaires pour les fonctions tryRead, tryTake, TakeAll, ReadAll sont aussi définis. Un test vérifiant qu'un callback peut se réengistrer est aussi donné. Enfin, l'application whiteboard fonctionne
exactement comme elle nous a été présentée lors de l'introduction au projet.

Puis, pour vérifier que la spécification est bien respectée, nous avons effectué des tests pour vérifier chacun des quatre points, nommés respectivement dans l'ordre :
\begin{itemize}
\item BasicTestTakeSpec1.java
\item BasicTestTakeSpec2.java
\item BasicTestTakeReadSpec3.java
\item BasicTestTakeCallbackSpec4.java
\end{itemize}

Ces tests-là pour les principaux, ajoutés à d'autres tests, donnant tous des résultats cohérents, nous permettent de valider notre implémentation. Il est à noter que certains tests finissent
sur des commandes bloquantes et il faut donc arrêter l'éxécution manuellement, cela est bien sûr fait exprès de manière à montrer dans certains cas le bon fonctionnement de nos fonctions.

\chapter{Version client / mono-serveur}

\section{Choix d'implémentation}

\chapter{Version multi-serveurs}

\section{Choix d'implémentation}

\end{document}
